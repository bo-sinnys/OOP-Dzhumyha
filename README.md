У ході виконання лабораторної роботи було розглянуто та реалізовано механізми обробки винятків, а також патерн Retry для підвищення надійності та відмовостійкості застосунку при роботі з файловою системою та мережевими ресурсами.

1. Обробка вводу/виводу у FileProcessor

У класі FileProcessor було реалізовано метод UpdateConfig, який імітує оновлення конфігураційного файлу та перші 2 рази генерує виняток IOException.

Це дозволило продемонструвати реальну ситуацію, коли доступ до файлу тимчасово заблокований (наприклад, файл зайнятий іншим процесом або виникла короткочасна проблема з файловою системою).

Результат аналізу

Обробка IOException є критично важливою при роботі з файлами.

Використання повторних спроб дозволяє уникнути аварійного завершення програми через тимчасову помилку.

Після кількох невдалих спроб операція завершується успішно — це підтверджує правильність реалізації Retry.

2. Обробка мережевих помилок у NetworkClient

Метод SendConfigUpdate у класі NetworkClient моделює відправку даних на сервер і перші 3 рази кидає HttpRequestException.

Такі ситуації часто виникають у реальних системах через:

тимчасові проблеми з інтернет-з'єднанням,

перевантаження сервера,

мережеві таймаути,

втрату пакетів.

Результат аналізу

Мережева взаємодія є найбільш нестабільним елементом у сучасному ПЗ.

Виняток HttpRequestException демонструє типову помилку HTTP-запиту.

Повторні спроби дозволили успішно завершити операцію після тимчасових збоїв.

3. Реалізація патерна Retry (RetryHelper)

Було створено універсальний статичний клас RetryHelper з методом:

ExecuteWithRetry(Func<T> operation, ...)

Що реалізовано:

✔ контроль кількості спроб
✔ експоненційна затримка між повтореннями
✔ логування кожної спроби
✔ обробка лише тих винятків, які визначені у shouldRetry
✔ можливість повторювати будь-яку операцію (узагальнені типи T)

Чому це важливо

Патерн Retry — один із ключових інструментів у розробці надійних систем, оскільки:

дозволяє відновити роботу після тимчасових збоїв,

знижує навантаження на систему, використовуючи експоненційні затримки,

покращує користувацький досвід,

дозволяє адаптуватися до нестабільних зовнішніх ресурсів.

4. Використання shouldRetry

У роботі створено делегат:

ex is IOException || ex is HttpRequestException


Цей механізм демонструє важливий принцип:

Повторювати операцію потрібно лише для тимчасових помилок.

Аналіз

Не всі винятки однакові: деякі можна “пережити”, а деякі слід обробляти негайно.

Такий підхід робить Retry безпечним і передбачуваним.

Це демонструє реальний промисловий підхід до обробки помилок.

5. Демонстрація у Main

У методі Main було виконано два сценарії:

1. Оновлення конфігурації в файлі

2 помилки → потім успіх

Retry спрацював коректно

2. Відправлення конфігурації на сервер

3 помилки → потім успіх

Retry дозволив виконати запит після стабілізації мережі

Висновок

Обидва сценарії підтвердили, що:

Retry працює надійно,

експоненційна затримка реалізована правильно,

логування дозволяє відслідковувати роботу кожної спроби.